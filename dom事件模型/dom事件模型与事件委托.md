# Dom事件模型与事件委托

### 徐上博

***

## Dom事件模型

Dom事件模型或者机制，简单而言就是分为两段：

1. “从外向内”寻找监听函数，叫做**事件捕获**；
2. “从内而外”寻找监听函数，叫做**事件冒泡**。

从外向内的意思就是在某个的监听事件触发时，从触发事件的元素最高父级开始寻找，慢慢深入最高父级的所有子级中，也就是**捕获**；<br>
从内而外反之，是从最小子级开始找起，直到最高父级，也就是**冒泡**。<br>
捕获与冒泡就是就是事件传播过程中的两个概念，顺序是**先捕获再冒泡**。是通过事件绑定函数`addEventListener()`实现的，其语法格式如下：

```js
addEventListener(event,function,bool);

event//字符串，不可省略，用于指定事件名，例如`click`,`wheel`等。
function//指定事件触发时要执行的函数，不可省略，
bool//为布尔值true或者false；为true时，事件句柄在捕获阶段执行；为false时，事件句柄在冒泡阶段执行；不输入第三个参数时，默认为为false。
```

***
## 事件委托

**事件委托是将在父级创建事件，然后将事件委托给子级执行，其原理是事件冒泡。**<br>

事件委托有哪些好处，才会被现在人们大量的使用呢？
那么就得先说说事件的一些性能和使用的问题：

1. 绑定事件越多，浏览器内存占用越大，严重影响性能。

2. 部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄漏，严重影响性能

这些个限制，都是直接给元素事件绑定带来的问题，所以经过了一些前辈的总结试验，也就有了事件委托这个解决方案。

事件委托的优点：

* 减少内存消耗
有如下一个元素，其有诸多子级，需求是要为每一个子级的文字都添加一个`click`事件：

```html
<div>
    <button>item 1</button>
    <button>item 2</button>
    <button>item 3</button>
    <button>item 4</button>
    ......
    <button>item 200</button>
</div>
```

如果单纯的为每一个子级都绑定一个函数，那无疑是对内存的巨大消耗。<br>
因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 `<div>` 上，然后在执行事件的时候再去匹配判断目标元素；<br>

所以事件委托可以减少大量的内存消耗，节约效率。

* 监听动态事件
当需要去监听一个未来才会有的元素时，事件委托就会方便许多，因为监听函数绑定的是父级，与这个元素存在与否无关，只需要在监听是判断一下即可。

***